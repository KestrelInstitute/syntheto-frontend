/*
 * generated by Xtext 2.23.0
 */
package edu.vanderbilt.isis.midas.validation

import edu.vanderbilt.isis.midas.syntheto.SynthetoPackage
import org.eclipse.xtext.validation.Check
import edu.vanderbilt.isis.midas.syntheto.SumTypeDefinition
import edu.vanderbilt.isis.midas.syntheto.Theorem
import edu.vanderbilt.isis.midas.syntheto.ProductTypeDefinition
import edu.vanderbilt.isis.midas.syntheto.SubTypeDefinition
import edu.vanderbilt.isis.midas.syntheto.FunctionSpecfication
import edu.vanderbilt.isis.midas.syntheto.PrimaryTypeElement
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.util.LineAndColumn
import edu.vanderbilt.isis.midas.syntheto.LiteralValue
import edu.vanderbilt.isis.midas.syntheto.VariableAssignment
import edu.vanderbilt.isis.midas.syntheto.ElementTagQualifier
import edu.vanderbilt.isis.midas.syntheto.Map
import edu.vanderbilt.isis.midas.syntheto.Set
import edu.vanderbilt.isis.midas.syntheto.Sequence
import edu.vanderbilt.isis.midas.syntheto.TypedVariable
import edu.vanderbilt.isis.midas.syntheto.TypeElement
import edu.vanderbilt.isis.midas.syntheto.SingleValueBuiltins
import edu.vanderbilt.isis.midas.syntheto.TwoValueBuiltins
import edu.vanderbilt.isis.midas.syntheto.FunctionCall
import edu.vanderbilt.isis.midas.syntheto.BridgeConnectionDirective
import edu.vanderbilt.isis.midas.syntheto.Program
import java.util.regex.Pattern
import java.util.regex.PatternSyntaxException
import edu.vanderbilt.isis.midas.syntheto.Ipaddress
import edu.vanderbilt.isis.midas.syntheto.SeqLiteral

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SynthetoValidator extends AbstractSynthetoValidator {

	static val myList = #['integer', 'int', 'boolean', 'bool', 'False', 'None', 'True', 'and', 'as', 'assert', 'async',
		'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from',
		'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try',
		'while', 'with', 'yield', 'struct', 'variant', 'map', 'seq', 'opt']

	@Check
	def checkNameNotKeyword(SumTypeDefinition element) {

		if (myList.contains(element.name)) {
			error("Name cannot be a keyword", SynthetoPackage.Literals.SUM_TYPE_DEFINITION__NAME)
		}
	}

	@Check
	def checkPragmaDirective(BridgeConnectionDirective directive) {
		var parent = directive.eContainer as Program
		var alldirectives = parent.commands.filter(BridgeConnectionDirective)
		if (alldirectives.size > 1) {
			error("Only one Bridge Connection Directive is allowed ", null)
		}
	}

	@Check
	def checkIPRange(BridgeConnectionDirective directive) {
		if (directive.host.isValid) {
			return true
		} else {
			error("Invalid IP", SynthetoPackage.Literals.BRIDGE_CONNECTION_DIRECTIVE__HOST)
		}

	}

	@Check
	def checkPort(BridgeConnectionDirective directive) {
		if (directive.port <= 0 || directive.port > 65535) {
			error("Invalid PORT", SynthetoPackage.Literals.BRIDGE_CONNECTION_DIRECTIVE__PORT)
		}
	}

	def boolean isValid(Ipaddress ipaddress) {

		var String ip = ipaddress.first.toString + "." + ipaddress.second.toString + "." + ipaddress.third.toString +
			"." + ipaddress.fourth.toString
		if(ip === null || ip.isEmpty()) return false;
		ip = ip.trim();
		if((ip.length() < 6) || (ip.length() > 15)) return false;
		try {

			var pattern = Pattern.compile(
				"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");
			var matcher = pattern.matcher(ip);
			return matcher.matches();
		} catch (PatternSyntaxException ex) {
			return false;
		}

	}

	@Check
	def checkOrder(PrimaryTypeElement primarytype) {
		if (primarytype.typeref !== null) {
			var srcNode = NodeModelUtils.getNode(primarytype)
			var line = NodeModelUtils.getLineAndColumn(srcNode, srcNode.offset)
			var typeref = primarytype.typeref
			var typerefNode = NodeModelUtils.getNode(typeref)
			var typerefline = NodeModelUtils.getLineAndColumn(typerefNode, typerefNode.offset)
			if (typerefline > line)
				error("Use of a type should be after its definition",
					SynthetoPackage.Literals.PRIMARY_TYPE_ELEMENT__TYPEREF)
		}

	}

	def operator_greaterThan(LineAndColumn column, LineAndColumn column2) {
		if (column.line > column2.line)
			return true
		else if (column.line == column2.line) {
			if (column.column >= column2.column)
				return true
		} else
			return false
	}

	@Check
	def checkNameNotKeyword(Theorem element) {

		if (myList.contains(element.name)) {
			error("Name cannot be a keyword", SynthetoPackage.Literals.THEOREM__NAME)
		}
	}

	@Check
	def checkNameNotKeyword(ProductTypeDefinition element) {

		if (myList.contains(element.productID)) {
			error("Name cannot be a keyword", SynthetoPackage.Literals.PRODUCT_TYPE_DEFINITION__PRODUCT_ID)
		}
	}

	@Check
	def checkNameNotKeyword(SubTypeDefinition element) {

		if (myList.contains(element.name)) {
			error("Name cannot be a keyword", SynthetoPackage.Literals.SUB_TYPE_DEFINITION__NAME)
		}
	}

	@Check
	def checkNameNotKeyword(FunctionSpecfication element) {

		if (myList.contains(element.name)) {
			error("Name cannot be a keyword", SynthetoPackage.Literals.FUNCTION_SPECFICATION__NAME)
		}
	}

	@Check
	def CheckBuiltIn(SingleValueBuiltins a) {
		if(a.empty) return true

		var element = a.element;
		if(element instanceof LiteralValue && (element as LiteralValue).value !== null &&
			(element as LiteralValue).value instanceof SingleValueBuiltins) return true
		if(element instanceof LiteralValue && (element as LiteralValue).value !== null &&
			(element as LiteralValue).value instanceof TwoValueBuiltins) return true
		if (element instanceof VariableAssignment && (element as VariableAssignment).variable !== null) {
			var child = (element as VariableAssignment).variable.realType
			if (child !== null && (child instanceof Map || child instanceof Set || child instanceof Sequence)) {
				return true
			}
		}
		error(
			'The built in function should only be applied to a sequence type, set type or a map type or a built in function.',
			SynthetoPackage.Literals.SINGLE_VALUE_BUILTINS__ELEMENT
		)

	}

	@Check
	def CheckBuiltIn(TwoValueBuiltins a) {
		var element = a.element;

		if (element instanceof FunctionCall && (element as FunctionCall).func !== null) {
			var child = (element as FunctionCall).func.returnlist
			var frontelement = child.get(0)
			var functype = frontelement.tag.type
			if (functype !== null && (functype instanceof Set || functype instanceof Sequence)) {
				return true
			}
		}

		if(element instanceof LiteralValue && (element as LiteralValue).value !== null &&
			(element as LiteralValue).value instanceof SeqLiteral) return true
		if(element instanceof LiteralValue && (element as LiteralValue).value !== null &&
			(element as LiteralValue).value instanceof SingleValueBuiltins) return true
		if(element instanceof LiteralValue && (element as LiteralValue).value !== null &&
			(element as LiteralValue).value instanceof TwoValueBuiltins) return true
		if (element instanceof VariableAssignment && (element as VariableAssignment).variable !== null) {
			var child = (element as VariableAssignment).variable.realType
			if (child !== null && (child instanceof Set || child instanceof Sequence)) {
				return true
			}
		}
		error(
			'The built in function should only be applied to a sequence type, set type or a built in function.',
			SynthetoPackage.Literals.TWO_VALUE_BUILTINS__ELEMENT
		)

	}

	@Check
	def CheckFunctionCallParams(FunctionCall a) {

		var realfunction = a.func
		if (a.args === null) {
			if (realfunction.param === null)
				return true
			else
				error(
					"Function call args should be the same number as parameters in function definition",
					SynthetoPackage.Literals.FUNCTION_CALL__ARGS
				)
		} else if (realfunction.param === null) {
			if (a.args === null)
				return true
			else
				error(
					"Function call args should be the same number as parameters in function definition",
					SynthetoPackage.Literals.FUNCTION_CALL__ARGS
				)
		} else {
			var numarguments = a.args.length
			var realfuncarguments = realfunction.param.length
			if (numarguments != realfuncarguments) {
				error(
					"Function call args should be the same number as parameters in function definition",
					SynthetoPackage.Literals.FUNCTION_CALL__ARGS
				)
			}

		}
	}

	@Check
	def CheckBuiltInFirstElement(TwoValueBuiltins a) {
		var element = a.element;
		if(element instanceof LiteralValue && (element as LiteralValue).value !== null &&
			(element as LiteralValue).value instanceof SingleValueBuiltins) return true
		if (element instanceof VariableAssignment && (element as VariableAssignment).variable !== null) {
			var child = (element as VariableAssignment).variable.realType
			if (child !== null && (child instanceof Set || child instanceof Sequence)) {
				var TypeElement realchild
				switch (child) {
					case child instanceof Set: realchild = (child as Set).element
					case child instanceof Sequence: realchild = (child as Sequence).element
				}
//				var firstparam = a.value.type
//				if (!compatible(firstparam, realchild)) {
//					error(
//						'The built in function first param should be of same type as the second param which should be a set or a sequence.',
//						SynthetoPackage.Literals.TWO_VALUE_BUILTINS__VALUE
//					)
//				}
			}
		}

	}

	def boolean compatible(TypeElement element, TypeElement element2) {
		if(element.class != element2.class) return false
		switch element {
			case element instanceof Set:
				return compatible((element as Set).element, (element2 as Set).element)
			case element instanceof Sequence:
				return compatible((element as Sequence).element, (element2 as Sequence).element)
			case (element instanceof PrimaryTypeElement && (element as PrimaryTypeElement).primary !== null):
				return ((element as PrimaryTypeElement).primary == (element2 as PrimaryTypeElement).primary)
			case (element instanceof PrimaryTypeElement && (element as PrimaryTypeElement).typeref !== null):
				return ((element as PrimaryTypeElement).typeref.equals((element2 as PrimaryTypeElement).typeref))
			default:
				return false
		}
	}

	def TypeElement getRealType(ElementTagQualifier variabletarget) {
		var firstvariable = variabletarget.child;
		var secondvariable = variabletarget.subelement
		if (secondvariable === null && firstvariable !== null) {
			return (firstvariable as TypedVariable).type
		}
		if (secondvariable !== null) {
			var rightmostvariable = (secondvariable as TypedVariable).type
			return rightmostvariable
		}
		return null
	}

}
