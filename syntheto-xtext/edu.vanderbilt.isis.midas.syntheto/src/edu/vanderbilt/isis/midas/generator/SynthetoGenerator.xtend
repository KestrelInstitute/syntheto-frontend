/*
 * generated by Xtext 2.23.0
 */
package edu.vanderbilt.isis.midas.generator

import com.google.common.html.HtmlEscapers
import com.google.common.util.concurrent.Monitor
import com.google.inject.Inject
import edu.kestrel.syntheto.ast.ASTNode
import edu.kestrel.syntheto.ast.Program
import edu.kestrel.syntheto.bridge.BridgeCommand
import edu.kestrel.syntheto.bridge.BridgeException
import edu.kestrel.syntheto.bridge.BridgeResponse
import edu.kestrel.syntheto.bridge.Util
import edu.vanderbilt.isis.midas.syntheto.BridgeConnectionDirective
import java.io.BufferedReader
import java.io.File
import java.io.IOException
import java.io.InputStreamReader
import java.io.PrintWriter
import java.io.StringWriter
import java.net.InetSocketAddress
import java.net.Socket
import java.text.SimpleDateFormat
import java.util.Date
import java.util.logging.FileHandler
import java.util.logging.Formatter
import java.util.logging.Handler
import java.util.logging.Level
import java.util.logging.LogRecord
import java.util.logging.Logger
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.util.CancelIndicator
import org.eclipse.xtext.validation.CheckMode
import org.eclipse.xtext.validation.IResourceValidator
import org.eclipse.xtext.validation.Issue

import static extension org.eclipse.xtext.EcoreUtil2.*
import edu.kestrel.syntheto.bridge.BridgeClient
import edu.kestrel.syntheto.outcome.OutcomeBuilder
import edu.kestrel.syntheto.sexpr.SExpression
import edu.kestrel.syntheto.outcome.Outcome
import edu.kestrel.syntheto.outcome.FunctionSuccess
import edu.kestrel.syntheto.outcome.TheoremSuccess
import edu.kestrel.syntheto.outcome.TransformationSuccess
import edu.kestrel.syntheto.outcome.TransformationFailure
import edu.kestrel.syntheto.outcome.ProofObligationFailure
import edu.kestrel.syntheto.outcome.UnexpectedFailure
import java.rmi.UnexpectedException
import edu.kestrel.syntheto.outcome.TypeSuccess
import edu.kestrel.syntheto.outcome.TheoremFailure

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HTMLFormatter extends Formatter {
	override String format(LogRecord rec) {
		var StringBuffer buf = new StringBuffer(1000);
		buf.append("<tr>\n");

		// colorize any levels >= WARNING in red
		if (rec.getLevel().intValue() >= Level.WARNING.intValue()) {
			buf.append("\t<td style=\"color:red\">");
			buf.append("<b>");
			buf.append(rec.getLevel());
			buf.append("</b>");
		} else {
			buf.append("\t<td>");
			buf.append(rec.getLevel());
		}

		buf.append("</td>\n");
		buf.append("\t<td>");
		buf.append(calcDate(rec.getMillis()));
		buf.append("</td>\n");
		if (rec.getLevel().intValue() < Level.WARNING.intValue()) {
			buf.append("\t<td>");
			buf.append(HtmlEscapers.htmlEscaper().escape(formatMessage(rec)));

		} else {
			buf.append("\t<td style=\"color:red\">");
			buf.append("<b>");
			buf.append(HtmlEscapers.htmlEscaper().escape(formatMessage(rec)));
			buf.append("</b>");
		}
		buf.append("</td>\n");
		buf.append("</tr>\n");

		return buf.toString();
	}

	def String calcDate(long millisecs) {
		var SimpleDateFormat date_format = new SimpleDateFormat("MMM dd,yyyy HH:mm");
		var Date resultdate = new Date(millisecs);
		return date_format.format(resultdate);
	}

	override String getHead(Handler h) {
		return "<!DOCTYPE html>\n<head>\n<style>\n" + "table { width: 100% }\n" + "th { font:bold 10pt Tahoma; }\n" +
			"td { font:normal 10pt Tahoma; }\n" + "h1 {font:normal 11pt Tahoma;}\n" + "</style>\n" + "</head>\n" +
			"<body>\n" + "<h1>" + (new Date()) + "</h1>\n" +
			"<table border=\"0\" cellpadding=\"5\" cellspacing=\"3\">\n" + "<tr align=\"left\">\n" +
			"\t<th style=\"width:10%\">Loglevel</th>\n" + "\t<th style=\"width:15%\">Time</th>\n" +
			"\t<th style=\"width:75%\">Log Message</th>\n" + "</tr>\n";
	}

	override String getTail(Handler h) {
		return "</table>\n</body>\n</html>";
	}
}

class SynthetoResult {
    enum ResultType {
        TRANSFORMATION_SUCCESS,
        TRANSFORMATION_FAILURE
    }

    var String message
    var ResultType result

    new(ResultType result, String message) {
        this.result = result
        this.message = message
    }
}

class SynthetoGenerator extends AbstractGenerator {

	var Logger Log;
// 'default'
	var bridgeHostName = "localhost"
	var bridgeHostPort = 55445
	var Socket socket = null
	var static Monitor mutex = new Monitor
	var connectToBridge = false
	var BridgeCommand command;
	var BridgeResponse response;
	var timeout = 2000;
	static boolean isBridgeInitialized = false;

	def resetWorld() throws BridgeException {
		processCommandResponsewithwrapper("(ubu 6)");
	}

	@Inject IResourceValidator resourceValidator;

	def Boolean checkResource(Resource resource, Logger log) {
		var issues = resourceValidator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		for (Issue issue : issues) {
			var message = "";
			switch (issue.getSeverity()) {
				case ERROR:
					message = ("Syntheto ERROR: " + resource.normalizedURI.lastSegment + " " +
						issue.getMessage())
				case WARNING:
					message = ("Syntheto WARNING: " + resource.normalizedURI.lastSegment + " " +
						issue.getMessage())
				default:
					message = ("Syntheto INFO " + resource.normalizedURI.lastSegment + " " + issue.getMessage()) // do nothing
			}
			if (log === null) {
				System.err.println(message);
			} else {
				log.severe(message);
			}
		}
		
		return issues.empty ? true : false;		
	}

	def Boolean processCommandResponse(String sexpression) throws BridgeException {
		Log.fine("Sending To Bridge " + sexpression);
		// Log.severe(sexpression);
		command.writeRawBridgeCommand(sexpression);
		var String screenOutput = response.readResponse();
		if (screenOutput.contains('FAILED')) {
			Log.severe("RECEIVED Response from the Bridge - there was a failure " + screenOutput)
			return false
		} else {
			Log.fine("RECEIVED Response from the Bridge " + screenOutput);
			return true
		}
	// Log.severe(screenOutput);
	}

	def processCommandResponsewithwrapper(String sexpression) throws BridgeException {
		Log.fine("Sending To Bridge " + sexpression);
		command.writeBridgeCommand(sexpression);
		var String screenOutput = response.readResponse();
		Log.fine("RECEIVED Response from the Bridge " + screenOutput);
	}
	
	def checkBridgeConnected() {
	    try {
            if (!isBridgeInitialized) {
                BridgeClient.connectToBridge("LISP_MV");
                isBridgeInitialized = true;
            }

            // For now, reset ACL2 every time.
            // TODO: remove this when notebooks are updated to be incremental
            BridgeClient.resetWorld();
		} catch (Exception e) {
		    System.err.print("Error communicating with bridge: " + e.getMessage());
		}
	}

    def String generate(Resource resource, Logger Log) {
		checkBridgeConnected();
		
		var visitor = new SynthetoVisitor("VSCodeProgram", Log)
		var edu.vanderbilt.isis.midas.syntheto.Program program = resource.allContents.toIterable.filter(edu.vanderbilt.isis.midas.syntheto.Program).head

		if (program === null) {
		    return null
		}

		var ASTNode acl2Program = visitor.doSwitch(program)
		var prog = acl2Program as Program
		
		var revGenerator = new SynthetoReverseGenerator()
		var allResults = ""

		for (topLevel : prog.tops) {
			var wrappedTop = Util.wrapTopLevelCommand(topLevel.toSExpression.toString)
			System.err.println("Sending " + wrappedTop + " to the bridge")

			var response = BridgeClient.returnCommandResponse(wrappedTop);
			var sexpr = response.lastParsedSExpression
			System.err.println("\nLast parsed SExpression: " + sexpr + "\n")
			var makeForm = Util.extractMakeForm2(sexpr)

			if (makeForm === null) {
				throw new BridgeException("could not find (MAKE-..) form in response")
			}

			var result = "Default response";
			System.err.println("Received SExpr: " + makeForm + "\n");
			var deserialized = OutcomeBuilder.fromSExpression(makeForm);
			if (deserialized instanceof FunctionSuccess) {
				result = "Function success: " + deserialized.info;
			} else if (deserialized instanceof TypeSuccess) {
				result = "Type success: " + deserialized.info;
			} else if (deserialized instanceof TheoremSuccess) {
				result = "Theorem success: " + deserialized.info;
			} else if (deserialized instanceof TheoremFailure) {
				result = "Theorem failure. ACL2 info:\n" + deserialized.toString()
			} else if (deserialized instanceof ProofObligationFailure) {
				result = "Proof obligation failure. ACL2 expression:\n" + deserialized.toString()
				result += "\nReversed Syntheto:\n"
				result += revGenerator.doExpression(deserialized.formula)			
			} else if (deserialized instanceof TransformationSuccess) {
			    result = "Transformation success; top levels:\n"
			    for (res : (deserialized as TransformationSuccess).getTopLevels()) {
			        result += revGenerator.doTopLevel(res)
			        result += "\n"
			    }
			} else if (deserialized instanceof TransformationFailure) {
                result = "Transformation success: " + deserialized.toString()
            } else if (deserialized instanceof UnexpectedFailure) {
				result = "Unexpected ACL2 failure:\n";
				result += (deserialized as UnexpectedFailure).toString()
			}
			
			allResults += result + "\n";
		}
		
		return allResults;
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (StackTraceElement ste : Thread.currentThread().getStackTrace()) {
 		   System.out.println(ste);
 		}
 		
 		System.out.println("Resource URI: " + resource.URI);
		
		var current = new File(".").getCanonicalPath()
		var logdirectory = current + "/logs"
		System.err.println("Current dir:" + current);
		var directory = new File(String.valueOf(logdirectory));
		if (!directory.exists()) {
			directory.mkdir();
		}

		if(!resource.checkResource(null)) return;
		var edu.vanderbilt.isis.midas.syntheto.Program program = resource.allContents.toIterable.filter(edu.vanderbilt.isis.midas.syntheto.Program).head
		if(program === null) return;

		mutex.enter
		try {
			Log = Logger.getLogger(resource.normalizedURI.lastSegment);
			for (h : Log.parent.handlers) {
				h.level = Level.SEVERE
			}

			Log.level = Level.FINE
			var filename = logdirectory + "/" + resource.normalizedURI.lastSegment + ".log.html"
			var fhandler = new FileHandler(filename, true)
			fhandler.setFormatter(new HTMLFormatter)
			fhandler.level = Level.ALL
			Log.addHandler(fhandler)

			var visitor = new SynthetoVisitor(resource.normalizedURI.lastSegment, Log)
			
			if (program.commands !== null) {
				BridgeClient.connectToBridge("LISP_MV")
            	BridgeClient.resetWorld()
            	        
				Log.info("Starting to Process " + resource.URI.lastSegment)
				var ASTNode acl2Program = visitor.doSwitch(program)
				
				// Previous functionality: process everything as a list at one time
				var acl2Sexpression = Util.wrapTopLevel((acl2Program as Program).tops)
				var stringrepr = (acl2Program as Program).toString
				fsa.generateFile(resource.URI.lastSegment + ".old.lisp", acl2Sexpression)
				fsa.generateFile(resource.URI.lastSegment + ".old.repr", stringrepr)
				System.err.println("Generation of old version complete. Open file://./src_gen/" + resource.URI.lastSegment +
					".old.lisp")
				Log.info("Log of execution://src_gen/" + resource.URI.lastSegment + ".old.lisp")
				
				var prog = acl2Program as Program
				var revGenerator = new SynthetoReverseGenerator()
				revGenerator.doGenerateSyntheto(prog)
				Log.info("Reversed Syntheto: ")
				for (s : revGenerator.getTopLevelStrings)
					Log.info(s)

				for (topLevel : prog.tops) {
					var wrappedTop = Util.wrapTopLevelCommand(topLevel.toSExpression.toString)
					System.err.println("Sending " + wrappedTop + " to the bridge")
					
					var response = BridgeClient.returnCommandResponse(wrappedTop);
            		var sexpr = response.lastParsedSExpression
            		var makeForm = Util.extractMakeForm2(sexpr)
            		
            		if (makeForm === null) { 
            			throw new BridgeException("could not find (MAKE-..) form in response")       
            		}
            		
            		var deserialized = OutcomeBuilder.fromSExpression(makeForm);
            		//if (!(node.equals(deserialized))) throw new BridgeException("makeForm did not build the same object as passed to the bridge");
            		System.out.println("Got the outcome:\n" + deserialized.toString());					
				}
				
//				if (connectToBridge == true && socket !== null) {
//					var out = processCommandResponse(acl2Sexpression)
//					if (out)
//						System.err.println(
//							"No error found in " + resource.URI.lastSegment + " after checking through ACL2")
//					processCommandResponsewithwrapper("(pbt 1)");
//					resetWorld()
//				}
			}
			
		} catch (Exception exception) {
			throw exception
		} finally {
			mutex.leave
		}
		
//		try {
//			Log = Logger.getLogger(resource.normalizedURI.lastSegment);
//			for (h : Log.parent.handlers) {
//				h.level = Level.SEVERE
//			}
//
//			Log.level = Level.FINE
//			var filename = logdirectory + "/" + resource.normalizedURI.lastSegment + ".log.html"
//			var fhandler = new FileHandler(filename, true)
//			fhandler.setFormatter(new HTMLFormatter)
//			fhandler.level = Level.ALL
//			Log.addHandler(fhandler)
//
//			var v = new SynthetoVisitor(resource.normalizedURI.lastSegment, Log)
//
//			if (program.commands !== null) {
//
//				var acl2connection = program.commands.filter(BridgeConnectionDirective)
//				if (acl2connection === null || acl2connection.size == 0)
//					connectToBridge = false
//				else {
//					connectToBridge = true
//					bridgeHostPort = acl2connection.head.port
//					bridgeHostName = acl2connection.head.host.first.toString + "." +
//						acl2connection.head.host.second.toString + "." + acl2connection.head.host.third.toString + "." +
//						acl2connection.head.host.fourth.toString
//
//					try {
//						socket = new Socket
//						Log.severe("trying to connect to " + bridgeHostName + ":" + bridgeHostPort)
//						socket.connect(new InetSocketAddress(bridgeHostName, bridgeHostPort), timeout);
//						var writer = new PrintWriter(socket.getOutputStream(), true);
//						var reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
//						command = new BridgeCommand(writer);
//						response = new BridgeResponse(reader);
//						response.Log = Log
//						response.readHello();
//
//						// processCommandResponse("(defun f3 (x) x)");
//						Log.info("Connection to Bridge Ready")
//
//					} catch (IOException e) {
//						Log.severe("Cannot connect to bridge." + e);
//						command = null
//						response = null
//						socket = null
//						connectToBridge = false
//					} catch (Exception e) {
//						Log.severe(e.stackTrace.toString)
//						connectToBridge = false
//						throw e
//					}
//				}
//
//			}
//
//			try {
//				if (program !== null) {
//					Log.info("Starting to Process " + resource.URI.lastSegment)
//					var ASTNode acl2Program = v.doSwitch(program)
//					var acl2Sexpression = Util.wrapTopLevel((acl2Program as Program).tops)
//					var stringrepr = (acl2Program as Program).toString
//					fsa.generateFile(resource.URI.lastSegment + ".lisp", acl2Sexpression)
//					fsa.generateFile(resource.URI.lastSegment + ".repr", stringrepr)
//					System.err.println("Generation complete. Open file://./src_gen/" + resource.URI.lastSegment +
//						".lisp")
//					Log.info("Log of execution://src_gen/" + resource.URI.lastSegment + ".lisp")
//
//					var prog = acl2Program as Program
//					var revGenerator = new SynthetoReverseGenerator()
//					revGenerator.doGenerateSyntheto(prog)
//					Log.info("Reversed Syntheto: ")
//					for (s : revGenerator.getTopLevelStrings)
//						Log.info(s)
//
//					if (connectToBridge == true && socket !== null) {
//						var out = processCommandResponse(acl2Sexpression)
//						if (out)
//							System.err.println(
//								"No error found in " + resource.URI.lastSegment + " after checking through ACL2")
//						processCommandResponsewithwrapper("(pbt 1)");
//						resetWorld()
//					}
//
//				} else {
//					Log.severe("No Program found")
//				}
//				System.err.println("Open Log File file://" + filename)
//			} catch (Exception exception) {
//				var sw = new StringWriter();
//				var pw = new PrintWriter(sw)
//				exception.printStackTrace(pw)
//				Log.severe(sw.toString)
//			}
//			for (h : Log.handlers)
//				h.close
//
//		} catch (Exception exception) {
//			throw exception
//		} finally {
//			mutex.leave
//			if (socket !== null) {
//				try {
//					socket.close
//				} catch (IOException e) {
//					Log.severe("Cannot close Socket" + e);
//				}
//
//			}
//		}
//	}
	}
}
